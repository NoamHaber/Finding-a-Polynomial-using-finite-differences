# Taking in sets of coordinates, This program seeks
# after a polynomial that defines a definite function f,
# behaving as the relation between the x value and the 
# y value through f(x). The way undertaken in this program
# for that is the method of finite differences on 
# polynomials as described here:
# https://en.wikipedia.org/wiki/Finite_difference
# and here:
# https://brilliant.org/wiki/method-of-differences
# If the program succeeds, the user can enter the word
# 'more' to see the full solution.


import pandas as pd
import math

# The data points below are optional. there are 2 other
# options to choose, or any the user knows to behave
# in the nature described.
#dataPoints=[[0,2],[1,3],[2,26],[3,89],[4,210]]
#dataPoints=[[1,-34],[2,-42],[3,-38],[4,-16],[5,30],[6,106]]
dataPoints=[[1,1],[2,-3],[3,5],[4,37],[5,105],[6,221]]

diffTables=[]

# This function handles the main algorithm that attempts
# to find the polynomial that defines f(x). it uses the 
# difference tables that are generated by the function diffGen()
# and applies it through the function dataChange() to create a dictionary
# that contain all the information that builds the polynomial- degrees and coefficients.
# the function outputs a Text string that represents the polynomial through 
# the function polyTextGen(). finally it allows the user to enter the string 'more'
# to recieve the full solution log.
def algoStructure(dataPoints):
    cordDict=cordsToDict(dataPoints)
    polyDict={'degree':[],'coefficients':[]}
    equationDeg=diffGen(cordDict)['degree']
    for x in range(equationDeg):
        curDiff=diffGen(cordDict)
        polyDict['degree'].insert(0,curDiff['degree'])
        polyDict['coefficients'].insert(0,curDiff['coefficients'])
        cordDict=dataChange(polyDict)
        if(polyDict['degree'][0]==0):
            break
        if (polyDict['degree'][0]==1):
            polyDict['coefficients'].insert(0,cordDict['f(x)'][0])
            polyDict['degree'].insert(0,0)
            break
    print('\nThe polynomial was found as: ')
    print('\n'+polyTextGen(polyDict))
    print('\nFor an elaborate explanation enter the word more')
    if(input()=='more'):
        print(proofTextGen(polyDict,diffTables,polyTextGen(polyDict)))

# Taking in sets of data points, this function stores a
# Data Frame which expresses a difference table as defined
# here: "https://brilliant.org/wiki/method-of-differences/",
# and returns a dictionary containg the degree of the diff'
# and the value of the difference
def diffGen(dataPoints):
    global diffTables
    diffdict={'f(x)':dataPoints['f(x)']}
    while(len(diffdict)<(len(dataPoints['f(x)'])-1) and isListNull(diffdict[list(diffdict)[-1]])!=True):
        currDiffList=[]
        for iter in range(len(diffdict[list(diffdict)[-1]])-1):
            currDiffList.append(diffdict[list(diffdict)[-1]][iter+1]-diffdict[list(diffdict)[-1]][iter])
        diffdict['d'+str(len(diffdict))+'(x)']=currDiffList
    del diffdict['f(x)']
    if(isListNull(diffdict[list(diffdict)[-1]])):
        del diffdict[list(diffdict)[-1]]
    dataPoints.update(diffdict)
    diffdict=dataPoints
    diffTables.append(pd.DataFrame.from_dict(diffdict,orient='index',dtype=object).T.reset_index(drop=True))
    if((list(diffdict)[-1])=='f(x)'):
        return coEffRet({'degree':0,'value':diffdict[list(diffdict)[-1]][0]})
    return coEffRet({'degree':int(list(diffdict)[-1][1]),'value':diffdict[list(diffdict)[-1]][0]})

# Taking in the dictionary which holds the information
# about the polynomial, this function returns a string of
# text which represents the polynomial.
def polyTextGen(polyDict):
    powerList=['⁰','¹','²','³','⁴','⁵','⁶','⁷','⁸','⁹']
    polyText=''
    for iter in reversed(polyDict['degree']):
        if(iter==0):
            polyText+=str(polyDict['coefficients'][0])
        else:
            polyText+=str(polyDict['coefficients'][polyDict['degree'].index(iter)])+'x'+powerList[iter]+'+'
    return polyText


# The following section contains small utility functions
# that are used above.

# Taking in sets of data points, This function
# returns two pairs, a 'x' pair and a f(x) pair
def cordsToDict(cordData):
    cordDict={'x':[],'f(x)':[]}
    for iter in cordData:
        cordDict['x'].append(iter[0])
        cordDict['f(x)'].append(iter[1])
    return cordDict

# Taking in a list, this function returns true if all
# the values in the list are 0
def isListNull(dataList):
    for iter in dataList:
        if(iter != 0):
            return False
    return True

# This function finds the coefficient in accordance
# to the degree and and the shared difference value.
def coEffRet(degData):
    coEffNum = (degData['value']) / (math.factorial(degData['degree']))
    if (coEffNum.is_integer()):
        return {'degree':degData['degree'],'coefficients':int(coEffNum)}
    return {'degree':degData['degree'],'coefficients':coEffNum}

# Taking in a dictionary containg the current degree
# and coefficient, the function returns new data pairs
# to turn into the next stage of difference computation 
# as described here:
# https://en.wikipedia.org/wiki/Finite_difference
def dataChange(polyDict):
    global dataPoints
    newCords=cordsToDict(dataPoints)
    for i in range(len(polyDict['degree'])):
        for j in range(len(newCords['x'])):
            newCords['f(x)'][j] = newCords['f(x)'][j] - (polyDict['coefficients'][i] * (newCords['x'][j] ** polyDict['degree'][i]))
    return newCords

#planned here is a function that checks the polynomial in relation to the values inputed.
#def polCheck(polydict):
#   global dataPoints


#Taking in the dictionary that defines the polynomial, the tables of differneces and the polynom
#as written in mathmatical notaion, this function returns a text string that is supposed to hold 
#a elaborate log of the building of the polynomial.
def proofTextGen(polydict,difTab,finPol):
    splitPol=finPol.split('+')
    proof=""
    proof+="\nThe following is the broad explanation of the way the polynomial was found."
    proof+="\nThe method used for the search of the polynomial is the method of finite differences"
    proof+="on polynomials as described here:"
    proof+="\n\bhttps://en.wikipedia.org/wiki/Finite_difference"
    proof+="\nand here:"
    proof+="\n\bhttps://brilliant.org/wiki/method-of-differences"
    proof+="\n\nThe coordinates are given:\n"+str(cordsToDict(dataPoints))
    proof+="\n\nFirstly, we create the first table of differences out of the coordinates:"
    proof+="\n"+str(difTab[0])
    proof+="\nThe number of differences needed to get an equal differance allows us to understand"
    proof+="\nthat the degree of the equation is "+str(polydict['degree'][-1])+"." 
    proof+="\nRespectively, following the equation in theorm, the coefficient equals to the last difference divided by the factorial of the degree,"
    proof+=" hence it equals to "+str(polydict['coefficients'][-1])+"."
    proof+="\n\nIn correspondence, we know that the the equation contains the term "+splitPol[0]+"."
    proof+="\nTherefore, if we remove that term's value from the f(x) values with respect to the fitting x values, we will recieve a polynomial of a lower degree. if we repeat so several times we will get the full polynomial."
    for x in range(2,len(difTab)):
        proof+="\nThe next difference table is: \n"
        proof+=str(difTab[x])
        proof+="\nHence, the next degree is "+str(polydict['degree'][-x])+" and it's coefficient is "+str(polydict['coefficients'][-x])+". Therefore the polynomial contains "+splitPol[x-1]
    proof+="\nIn a simple equation using x and the proven partial polynomial built until now, the remaining number to add to the polynomial is: "
    proof+=str(polydict['coefficients'][0])+". Hence the final polynomial is:\n\n"
    proof+=finPol
    return proof

algoStructure(dataPoints)

