# Taking in sets of coordinates, This program seeks
# after a polynomial that defines a definite function f,
# behaving as the relation between the x value and the 
# y value through f(x). The way undertaken in this program
# for that is the method of finite differences on 
# polynomials as described here:
# https://en.wikipedia.org/wiki/Finite_difference
# and here:
# https://brilliant.org/wiki/method-of-differences
# If the program succeeds, the user can enter the word
# 'more' to see the full solution.


import pandas as pd
import math

FX = 'f(x)'
X = 'x'

# The data points below are optional. there are 2 other
# options to choose, or any the user knows to behave
# in the nature described.
#data_points=[[0,2],[1,3],[2,26],[3,89],[4,210]]
#data_points=[[1,-34],[2,-42],[3,-38],[4,-16],[5,30],[6,106]]
data_points=[[1,1],[2,-3],[3,5],[4,37],[5,105],[6,221]]

difference_tables=[]

# This is the main function that runs in the program. it inputs the data points into the
# the function algorithm_execute and prints out the polynomial that was found. if the users continues
# entering the string 'more', a full proof is printed using proof_text_generator()
def main():
    polynomialResult=algorithm_execute(data_points)
    print(f"""
The polynomial was found as:
{render_polynomial(polynomialResult['polynomial_dictionary'])}
For an elaborate explanation enter the word more.""")
    if(input()=='more'):
        print(proof_text_generator(polynomialResult['polynomial_dictionary'],difference_tables,polynomialResult['polynomial_in_text']))

# This function handles the main algorithm that attempts
# to find the polynomial that defines f(x). it uses the 
# difference tables that are generated by the function difference_dictionary_generator()
# and applies it through the function data_change() to create a dictionary
# that contain all the information that builds the polynomial- degrees and coefficients.
# the function returns a Dictionary that holds two results:a)the polynomial through 
# the function render_polynomial(), b) the dictionary that holds the polynomials information.
def algorithm_execute(data_points):
    polynomial_dictionary={'degree':[],'coefficients':[]}
    cordDict=cords_to_dictionary(data_points)
    equationDeg=difference_dictionary_generator(cordDict)['degree']
    for _ in range(equationDeg):
        curDiff=difference_dictionary_generator(cordDict)
        polynomial_dictionary['degree'].insert(0,curDiff['degree'])
        polynomial_dictionary['coefficients'].insert(0,curDiff['coefficients'])
        cordDict=data_change(polynomial_dictionary)
        if(polynomial_dictionary['degree'][0]==0):
            break
        if (polynomial_dictionary['degree'][0]==1):
            polynomial_dictionary['coefficients'].insert(0,cordDict[FX][0])
            polynomial_dictionary['degree'].insert(0,0)
            break
    return({'polynomial_in_text':render_polynomial(polynomial_dictionary),'polynomial_dictionary':polynomial_dictionary})
    

# Taking in sets of data points, this function stores a
# Data Frame which expresses a difference table as defined
# here: "https://brilliant.org/wiki/method-of-differences/",
# and returns a dictionary containg the degree of the diff'
# and the value of the difference
def difference_dictionary_generator(data_points):
    global difference_tables
    difference_dictionary={FX:data_points[FX]}
    while(len(difference_dictionary)<(len(data_points[FX])-1) and isListNull(difference_dictionary[list(difference_dictionary)[-1]])!=True):
        current_difference_List=[]
        for iter in range(len(difference_dictionary[list(difference_dictionary)[-1]])-1):
            current_difference_List.append(difference_dictionary[list(difference_dictionary)[-1]][iter+1]-difference_dictionary[list(difference_dictionary)[-1]][iter])
        difference_dictionary['d'+str(len(difference_dictionary))+'(x)']=current_difference_List
    del difference_dictionary[FX]
    if(isListNull(difference_dictionary[list(difference_dictionary)[-1]])):
        del difference_dictionary[list(difference_dictionary)[-1]]
    data_points.update(difference_dictionary)
    difference_dictionary=data_points
    difference_tables.append(pd.DataFrame.from_dict(difference_dictionary,orient='index',dtype=object).T.reset_index(drop=True))
    if((list(difference_dictionary)[-1])==FX):
        return coefficients_return({'degree':0,'value':difference_dictionary[list(difference_dictionary)[-1]][0]})
    return coefficients_return({'degree':int(list(difference_dictionary)[-1][1]),'value':difference_dictionary[list(difference_dictionary)[-1]][0]})

# Taking in the dictionary which holds the information
# about the polynomial, this function returns a string of
# text which represents the polynomial.
def render_polynomial(polynomial_dictionary):
    powerList=['⁰','¹','²','³','⁴','⁵','⁶','⁷','⁸','⁹']
    terms=[]
    for coefficient, degree in zip(polynomial_dictionary["coefficients"], polynomial_dictionary['degree']):
        if degree==0:
            terms.append(str(coefficient))
        else: 
            terms.append(f"{coefficient}{X}{powerList[degree]}")
    return "+".join(reversed(terms))


# The following section contains small utility functions
# that are used above.

# Taking in sets of data points, This function
# returns a dictionary containing two pairs, a X pair and a f(x) pair
def cords_to_dictionary(cordData):
    cordDict={X:[],FX:[]}
    for iter in cordData:
        cordDict[X].append(iter[0])
        cordDict[FX].append(iter[1])
    return cordDict

# Taking in a list, this function returns true if all
# the values in the list are 0
def isListNull(dataList):
    return not any(x != 0 for x in dataList)

# This function finds the coefficient in accordance
# to the degree and and the shared difference value.
def coefficients_return(degData):
    coefficient_value = (degData['value']) / (math.factorial(degData['degree']))
    if (coefficient_value.is_integer()):
        return {'degree':degData['degree'],'coefficients':int(coefficient_value)}
    return {'degree':degData['degree'],'coefficients':coefficient_value}

# Taking in a dictionary containg the current degree
# and coefficient, the function returns new data pairs
# to turn into the next stage of difference computation 
# as described here:
# https://en.wikipedia.org/wiki/Finite_difference
def data_change(polynomial_dictionary):
    global data_points
    new_cords=cords_to_dictionary(data_points)
    for i in range(len(polynomial_dictionary['degree'])):
        for j in range(len(new_cords[X])):
            new_cords[FX][j] = new_cords[FX][j] - (polynomial_dictionary['coefficients'][i] * (new_cords[X][j] ** polynomial_dictionary['degree'][i]))
    return new_cords

#Taking in the dictionary that defines the polynomial, the tables of differneces and the polynom
#as written in mathmatical notaion, this function returns a text string that is supposed to hold 
#a elaborate log of the building of the polynomial.
def proof_text_generator(polynomial_dictionary,difference_tables,final_polynomial):
    split_polynomial=final_polynomial.split('+')
    proof=f"""
The following is the broad explanation of the way the polynomial was found.
The method used for the search of the polynomial is the method of finite differences on polynomials as described here:
https://en.wikipedia.org/wiki/Finite_difference
and here:
https://brilliant.org/wiki/method-of-differences

The coordinates are given:{cords_to_dictionary(data_points)})

Firstly, we create the first table of differences out of the coordinates:
{difference_tables[0]}

The number of differences needed to get an equal differance allows us to understand
that the degree of the equation is{polynomial_dictionary['degree'][-1]}.

Respectively, following the equation in theorm, the coefficient equals to the last difference divided by the factorial of the degree,"
hence it equals to "+{polynomial_dictionary['coefficients'][-1]}.

In correspondence, we know that the the equation contains the term {split_polynomial[0]}
Therefore, if we remove that term's value from the f(x) values with respect to the fitting x values, we will recieve a polynomial of a lower degree. if we repeat so several times we will get the full polynomial
    """
    for x in range(2,len(difference_tables)):
        proof+=f"""
The next difference table is: 
{difference_tables[x]}

Hence, the next degree is {polynomial_dictionary['degree'][-x]} and it's coefficient is {polynomial_dictionary['coefficients'][-x]}.  Therefore the polynomial contains {split_polynomial[x-1]}
        """
    proof+=f"""
In a simple equation using x and the proven partial polynomial built until now, the remaining number to add to the polynomial is:
{polynomial_dictionary['coefficients'][0]} Hence the final polynomial is:
{final_polynomial}
    """
    return proof

if __name__ == "__main__":
    main()
