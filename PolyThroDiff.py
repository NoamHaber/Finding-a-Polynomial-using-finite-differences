# Taking in sets of coordinates, This program seeks
# after a polynomial that defines a definite function f,
# behaving as the relation between the x value and the 
# y value through f(x). The way undertaken in this program
# for that is the method of finite differences on 
# polynomials as described here:
# https://en.wikipedia.org/wiki/Finite_difference
# and here:
# https://brilliant.org/wiki/method-of-differences
# If the program succeeds, the user can enter the word
# 'more' to see the full solution.


import pandas as pd
import math

FX = 'f(x)'
X = 'x'

# The data points below are optional. there are 2 other
# options to choose, or any the user knows to behave
# in the nature described.


#data_points=[[0,-4],[1,-2],[2,0],[3,2],[4,4],[5,6]]
#data_points=[[0,0],[1,1],[2,4],[3,9],[4,16],[5,25]]
#data_points=[[0,2],[1,3],[2,26],[3,89],[4,210]]
#data_points=[[1,-34],[2,-42],[3,-38],[4,-16],[5,30],[6,106]]
data_points=[[1,1],[2,-3],[3,5],[4,37],[5,105],[6,221]]

# This is the main function that runs in the program. it inputs the data points into the
# the function algorithm_execute and prints out the polynomial that was found. if the users continues
# entering the string 'more', a full proof is printed using proof_text_generator()
def main():
    # The program ensures that there is more than two data points
    if(len(data_points)>2):
        polynomialResult=algorithm_execute(data_points)
        if(algorithm_execute(data_points) == False):
            print("The polynomial was not found due to lack of data, or there not being a polynomial that fits the definition")
        else:
            print(f"""
The polynomial was found as:
{render_polynomial(polynomialResult['polynomial_dictionary']).replace('+-','-')}
For an elaborate explanation enter the word more.""")
            if(input()=='more'):
                print(proof_text_generator(polynomialResult['polynomial_dictionary'],polynomialResult['polynomial_dictionary']['difference_tables'],polynomialResult['polynomial_in_text']))
    else:
        print("The program is intended at finding a polynomial from at least 3 data points.")
# This function handles the main algorithm that attempts
# to find the polynomial that defines f(x). it uses the 
# difference tables that are generated by the function difference_dictionary_generator()
# and applies it through the function data_change() to create a dictionary
# that contain all the information that builds the polynomial- degrees and coefficients.
# the function returns a Dictionary that holds two results:a)the polynomial through 
# the function render_polynomial(), b) the dictionary that holds the polynomials information.
def algorithm_execute(data_points):
    polynomial_dictionary={'degree':[],'coefficients':[],'difference_tables':[]}
    cord_dictionary=cords_to_dictionary(data_points)
    if(difference_dictionary_generator(cord_dictionary,polynomial_dictionary['difference_tables']) == False):
        return False
    equationDeg=difference_dictionary_generator(cord_dictionary,polynomial_dictionary['difference_tables'])['degree']
    for _ in range(equationDeg):
        if(isListNull(cord_dictionary[FX])):
            break
        current_difference=difference_dictionary_generator(cord_dictionary,polynomial_dictionary['difference_tables'])
        polynomial_dictionary['degree'].insert(0,current_difference['degree'])
        polynomial_dictionary['coefficients'].insert(0,current_difference['coefficients'])
        polynomial_dictionary['difference_tables']=current_difference['updated_difference_tables']
        cord_dictionary=data_change(polynomial_dictionary)
        if(polynomial_dictionary['degree'][0]==0):
            break
        if (polynomial_dictionary['degree'][0]==1):
            polynomial_dictionary['coefficients'].insert(0,cord_dictionary[FX][0])
            polynomial_dictionary['degree'].insert(0,0)
            break
    return({'polynomial_in_text':render_polynomial(polynomial_dictionary),'polynomial_dictionary':polynomial_dictionary})
    

# Taking in sets of data points, this function stores a
# Data Frame which expresses a difference table as defined
# here: "https://brilliant.org/wiki/method-of-differences/",
# and returns a list containing two items, a) the updated
# difference tables, b) a dictionary containg the degree of the diff'
# and the value of the difference
def difference_dictionary_generator(data_points,difference_tables):
    difference_dictionary_return={}
    updated_difference_tables=difference_tables
    # The error flag is raised when the differences never 
    # reach equality, meaning either there is no polynomial
    # or the data isnt sufficient.
    difference_dictionary={FX:data_points[FX]}
    # The while loop goes on as long as the differences are not
    # equal to each other in which case the difference degree
    # was found
    while(isRecurring(difference_dictionary[list(difference_dictionary)[-1]]) != True):
        current_difference_List=[]
        for iter in range(len(difference_dictionary[list(difference_dictionary)[-1]])-1):
            current_difference_List.append(difference_dictionary[list(difference_dictionary)[-1]][iter+1]-difference_dictionary[list(difference_dictionary)[-1]][iter])
        difference_dictionary['d'+str(len(difference_dictionary))+'(x)']=current_difference_List
    del difference_dictionary[FX]
    # Two errors make the polynomial unsolvable: a) the last difference list being
    # different, meaning a comman difference wasnt found, or the last difference list
    # having only one item.
    if(difference_dictionary):
        if(isRecurring(difference_dictionary[list(difference_dictionary)[-1]])!=True or len(difference_dictionary[list(difference_dictionary)[-1]])<2):
            return False
    data_points.update(difference_dictionary)
    difference_dictionary=data_points
    updated_difference_tables.append(pd.DataFrame.from_dict(difference_dictionary,orient='index',dtype=object).T.reset_index(drop=True))
    if((list(difference_dictionary)[-1])==FX):
        difference_dictionary_return=coefficients_return({'updated_difference_tables':updated_difference_tables,'degree':0,'value':difference_dictionary[list(difference_dictionary)[-1]][0]})
        difference_dictionary_return['updated_difference_tables']=updated_difference_tables
        return difference_dictionary_return
    difference_dictionary_return=coefficients_return({'degree':int(list(difference_dictionary)[-1][1]),'value':difference_dictionary[list(difference_dictionary)[-1]][0]})
    difference_dictionary_return['updated_difference_tables']=updated_difference_tables
    return difference_dictionary_return

# Taking in the dictionary which holds the information
# about the polynomial, this function returns a string of
# text which represents the polynomial.
def render_polynomial(polynomial_dictionary):
    powerList=['⁰','¹','²','³','⁴','⁵','⁶','⁷','⁸','⁹']
    terms=[]
    for coefficient, degree in zip(polynomial_dictionary["coefficients"], polynomial_dictionary['degree']):
        if degree==0:
            terms.append(str(coefficient))
        else: 
            terms.append(f"{coefficient}{X}{powerList[degree]}")
    # This map changes items in the 'terms' list to be more
    # aesthetic for the human eye
    terms=list(map(lambda term:term.replace('1x','x').replace('+0','').replace('¹',''),terms))
    return "+".join(reversed(terms))


# The following section contains small utility functions
# that are used above.

# Taking in sets of data points, This function
# returns a dictionary containing two pairs, a X pair and a f(x) pair
def cords_to_dictionary(coordinate_data):
    cord_dictionary={X:[],FX:[]}
    for iter in coordinate_data:
        cord_dictionary[X].append(iter[0])
        cord_dictionary[FX].append(iter[1])
    return cord_dictionary

# Taking in a list, this function returns true if all
# the values in the list are 0
def isListNull(dataList):
    return not any(x != 0 for x in dataList)

# Taking in a list, this function returns True if all
# the items are the same
def isRecurring(dataList):
    return not any(x != dataList[0] for x in dataList)


# This function finds the coefficient in accordance
# to the degree and and the shared difference value.
def coefficients_return(degree_data):
    coefficient_value = (degree_data['value']) / (math.factorial(degree_data['degree']))
    if (coefficient_value.is_integer()):
        return {'degree':degree_data['degree'],'coefficients':int(coefficient_value)}
    return {'degree':degree_data['degree'],'coefficients':coefficient_value}

# Taking in a dictionary containg the current degree
# and coefficient, the function returns new data pairs
# to turn into the next stage of difference computation 
# as described here:
# https://en.wikipedia.org/wiki/Finite_difference
def data_change(polynomial_dictionary):
    new_cords=cords_to_dictionary(data_points)
    for i in range(len(polynomial_dictionary['degree'])):
        for j in range(len(new_cords[X])):
            new_cords[FX][j] = new_cords[FX][j] - (polynomial_dictionary['coefficients'][i] * (new_cords[X][j] ** polynomial_dictionary['degree'][i]))
    return new_cords

#Taking in the dictionary that defines the polynomial, the tables of differneces and the polynom
#as written in mathmatical notaion, this function returns a text string that is supposed to hold 
#a elaborate log of the building of the polynomial.
def proof_text_generator(polynomial_dictionary,difference_tables,final_polynomial):
    split_polynomial=final_polynomial.split('+')
    proof=f"""
The following is the broad explanation of the way the polynomial was found.
The method used for the search of the polynomial is the method of finite differences on polynomials as described here:
https://en.wikipedia.org/wiki/Finite_difference
and here:
https://brilliant.org/wiki/method-of-differences

The coordinates are given:{cords_to_dictionary(data_points)})

Firstly, we create the first table of differences out of the coordinates:
{difference_tables[0]}

The number of differences needed to get an equal differance allows us to understand
that the degree of the equation is {polynomial_dictionary['degree'][-1]}.

Respectively, following the equation in theorm, the coefficient equals to the last difference divided by the factorial of the degree,
hence it equals to {polynomial_dictionary['coefficients'][-1]}.

In correspondence, we know that the the equation contains the term {split_polynomial[0]}
Therefore, if we remove that term's value from the f(x) values with respect to the fitting x values, we will recieve a polynomial of a lower degree. if we repeat so several times we will get the full polynomial
    """
    for x in range(2,len(difference_tables)-1):
        proof+=f"""
The next difference table is: 
{difference_tables[x]}

Hence, the next degree is {polynomial_dictionary['degree'][-x]} and it's coefficient is {polynomial_dictionary['coefficients'][-x]}.  Therefore the polynomial contains {split_polynomial[x-1]}
        """
    proof+=f"""
In a simple equation using x and the proven partial polynomial built until now, the remaining number to add to the polynomial is:
{polynomial_dictionary['coefficients'][0]} Hence the final polynomial is:
{final_polynomial.replace('+-','-')}
    """
    return proof

if __name__ == "__main__":
    main()
